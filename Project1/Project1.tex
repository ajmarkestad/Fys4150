%%%%
\documentclass[a4paper,11pt]{article}
%%%%
%%%%
%PACKAGES______________________________________________________________________________________
\usepackage{simplewick} %Allows Wick Notation
\usepackage{slashed} %Allows feynman slash notation 
\usepackage{graphicx} % graphics, pictures, figures
\usepackage{verbatim} % importing numerical scripts
\usepackage{multicol, float} % placing floats in right places
\usepackage{algpseudocode} % no idea...
\usepackage[utf8]{inputenc}
\usepackage{amssymb} %needed if not using mathdesign
\usepackage{amsmath}
\usepackage[OT1]{fontenc}
\usepackage{lmodern} %gfsartemisia, times, boisik, et cetera
\usepackage{braket} %dirac notation
\usepackage[cm]{fullpage} % for fulpage style
\usepackage{bm} % boldface vectors
\usepackage{float} % placing floats
\usepackage{relsize} % for \mathlarger command
\usepackage{mathrsfs} %?
\usepackage{textgreek} % cb-greek class
\usepackage{sectsty} % for centering sections
\usepackage{textcomp } % for nr. symbol
\usepackage[usenames, dvipsnames]{color} % defining own colors
\usepackage{type1cm} % scalable fonts
\usepackage{lettrine} % larger first letter in paragraph.
\usepackage{listings}
\usepackage{background} % used for top page text
%\usepackage{niceframe} % for old-school double frame
\usepackage{tikz} % figure config/ creation
%\usepackage{bbold}
%\usepackage{swrule} % for fancy line
%\usepackage{pdfpages} % for importing pdf
%\usepackage{subfigure} % for subfigures
%%%%
%%%% SET-UP NEEDED FOR FURTHER PACKAGES
%%%%
\definecolor{hyperclrblue}{RGB}{30,90,125} %Definind own color ; blue
\definecolor{hyperclrorng}{RGB}{210,100,45}%Definind own color
\definecolor{hyperclrgreen}{RGB}{60,120,20}%Definind own color
\usepackage[colorlinks = true,
linkcolor = hyperclrblue,
urlcolor = blue,
citecolor = blue,
anchorcolor = blue]{hyperref} % link package
\usepackage{pgfplots} % to plot directly into latex
\pgfplotsset{compat=1.5} % needed forpgfplots
\usepackage{framed, color} % for framing/shaded box
\definecolor{shadecolor}{cmyk}{0,0,0.185,0} % color for shaded box
\usepackage{fancybox}
\usepackage[sc]{titlesec} % title package
%_______________________________________________________________________________________________
%NEW COMMANDS_________________________________________________________________________________
%\renewcommand*{\thefootnote}{$\dagger$} % creating dagger footnote
\newcommand*{\boisik}{\fontfamily{bsk}\selectfont} % change font to boisik command
\newcommand{\wf}{\text{\textpsi}} % defining wavefunctions as cbgreek class.
\newcommand{\bwf}{\text{\textPsi}} % defining Wavefunctions as cbgreek class.
\newcommand{\Q}{\hat{\text{\boisik Q}}} % defining operator-style 'Q'
\newcommand{\nlm}{\ket{n\ell m_\ell}} % defining wavefunctions as cbgreek class.
\newcommand{\nlmz}{\ket{n\ell m_\ell;0}} % defining wavefunctions as cbgreek class.
\newcommand{\nlmt}{\ket{n\ell m_\ell;t}} % defining wavefunctions as cbgreek class.
%_____________________________________________
%\numberwithin{equation}{section} %equations labeled by section
\sectionfont{\centering} % centering sections with 'sectsty'
\subsectionfont{\centering} % centering sections with 'sectsty'
\definecolor{myclr}{RGB}{190,90,20} %Definind own color
\renewcommand{\thesection}{\Roman{section}.} % Roman numerals for sections
\renewcommand{\thesubsection}{\Alph{subsection}} % Roman numerals for subsections
\titleformat{\section}{\large\scshape\centering}{\thesection}{1em}{} % Change the look of the section titles
\titleformat{\subsection}{\normalsize\centering\bfseries}{\thesubsection.}{1em}{} % Change the look of the section titles
\setlength{\columnsep}{0.7cm}
%______________________________________________________________________________________________
%%%%
%%%%_________________________________________________________________________________________
\begin{document}
%%%% TOP PAGE TEXT
{\SetBgContents{ \textit{{\small\textsc{ Ask J. Markestad, Thorbjørn V. Larsen, Ingrid A. V. Holm Universitetet i Oslo. \hspace{0.5cm} \textit{\today}}}}}
\SetBgScale{1}
\SetBgColor{black}
\SetBgAngle{0}
\SetBgOpacity{1}
\SetBgPosition{current page.north east}
\SetBgVshift{-1.2cm}
\SetBgHshift{-10.5cm}
%%%% CREATING TITLE HEADER
$$\:$$
\begin{center}
\vspace{0.2cm}%\boisik
\fontsize{15}{15}\selectfont \textsc{ Project 1: Vector and Matrix Operations in c++},\\
%{in}}\\
\fontsize{13}{13}\selectfont \textsc{Fys $\textnormal{{4150}}$ }\\
\vspace{0.4cm}
\fontsize{12}{12}\selectfont {\textsc{ Ask J. Markestad, Thorbjørn V. Larsen, Ingrid A. V. Holm }}\\
\vspace{0.5cm}
\end{center}
%%%%
%%%%
%______________________________________________________________________________________________
%%%%
%%%%

%\includegraphics[scale = 0.48]{line}
\rule{\textwidth}{0.3pt}\par

%---------------------------------------------------------------------------------------------------------------------------------------


\section*{Introduction}

Differential equations are fundamental in physics. The standard approach in most branches of physics is to describe a physical system in terms of it's symmetries and degrees of freedom through the formalism of Lagrange or Hamilton, i.e. by setting up equations of motion. It is thus a very important tool to be able to solve these differential equations as precisely and effectively as possible. In this project we explore algorithms for calculating second order differential equations using vector and matrix operations with the aim to better understand the computational demands of differential equation solutions and how to reduce these demands.



\section*{Theory and Algorithms}

We will be looking in detail at linear second-order differential equations.

$$\frac{d^2y}{dx^2} = k^2(x) y = f(x)$$

More specifically, we will look at differential equations where $k^2(x) = 0$. A known physics example of this type of equation would be Poisson's equation in radial coordinates for spherically symmetric source term.

$$\frac{d^2 \phi}{d r^2} = f(r)$$

In Newtonian gravity or in electromagnetism the source term is associated with a charge or mass distribution with a negative sign to explicitly indicate the attractiveness of the resulting potential. We will therefore look closely at the equation:

\begin{equation}
	- u''(x) = f(x)
	\label{diff_eq}
\end{equation}

With Dirichlet boundary conditions, i.e. $ x \in (0,1), \: \: u(0) = u(1) = 0$. To solve this equation numerically we need to discretize the functions $u$ and $f$ with grid points $x_i = i h$ from 0 to 1 in $n+1$ steps using step length $h = 1/(n+1)$. This means that we know the initial and final point of $u$ through the boundary conditions, and that we can use the three point derivative formula to rewrite the equation as:

\begin{equation}
- \frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} = f_i \: \: \: \: \: \: \: \: \text{for} \: \: i = 1, 2, ... , n
\label{disc_diff_eq}
\end{equation}

The solution to this equation with the given boundary conditions is $u(x) = 1 - (1-e^{-10}) - e^{-10x}$. For $x = 0$ we get $u(0) = 1 - (1 - e^{-10})*0 - e^{-10 * 0} = 1-1 = 0$, and for $x = 1$ we get $u(1) = 1 - 1 + e^{-10} - e^{-10} = 0$, so it satisfies the boundary conditions and by deriving it twice we get $u'(x) = -(1-e^{-10}) + 10e^{-10x}, \: \: \: u''(x) = -100 e^{-10x}$. So we have found the exact solution to the differential equation which gives us a value to compare to, to see the accuracy of our numerical method. The next step to solve the equation is to rewrite it as a linear set of equations:

\begin{equation}
\begin{pmatrix}
2 & -1 & 0 & ... & ... & 0 \\
-1 & 2 & -1 & 0 & ... & 0 \\
0 & -1 & 2 & -1 & 0 & ... \\
... & ... & ... & ... & ... & ... \\
0 & ... & 0 & -1 & 2 & -1 \\
0 & 0 & ... & 0 & -1 & 2 
\end{pmatrix} \begin{pmatrix}
u_1\\
u_2\\
u_3\\
...\\
...\\
u_n
\end{pmatrix} = \begin{pmatrix}
f_1/h^2 \\
f_2/h^2 \\
f_3/h^2 \\
... \\
... \\
f_n/h^2 \\
\end{pmatrix}
\end{equation}

We will now take a step back and look at a more general matrix $\mathbf{A}$ for this sort of linear problem and developing an algorithm for it. This allows us to see the difference in CPU time between the general algorithm and one made specifically for our very symmetric case. The more general matrix we will look at is a tridiagonal matrix:

\begin{equation}
\mathbf{A} = \begin{pmatrix}
b_1 & c_1 & 0 & ... & ... & 0 \\
a_1 & b_2 & c_2 & 0 & ... & 0 \\
0 & a_2 & b_3 & c_3 & 0 & ... \\
... & ... & ... & ... & ... & ... \\
0 & ... & 0 & a_{n-2} & b_{n-1} & c_{n-1} \\
0 & 0 & ... & 0 & a_{n-1} & b_{n} 
\end{pmatrix}
\label{general_tridiagonal_matrix}
\end{equation}

We now see that this problem is on the type $\mathbf{A}\mathbf{u}=\mathbf{f}$ were we know the values of $\mathbf{A}$ and $\mathbf{f}$. A solution for this problem is to form a diagonal matrix of $\mathbf{A}$, such that we easily can read out the values of $\mathbf{u}$. As the matrix is tridiagonal we can do this in two steps, forwardsubstitution where we remove the $a$ values and backwardssubstitution were we remove the $c$ values. Looking at the first 2 rows, we see that if we subtract the first row multiplied by $a_1/b_1$ we get

\begin{equation}
\begin{pmatrix}
b_1 & c_1 & 0 & ... & ... & 0 \\
0 & b_2-\frac{a_1 c_1}{b_1} & c_2 & 0 & ... & 0 \\
0 & a_2 & b_3 & c_3 & 0 & ... \\
... & ... & ... & ... & ... & ... \\
0 & ... & 0 & a_{n-2} & b_{n-1} & c_{n-1} \\
0 & 0 & ... & 0 & a_{n-1} & b_{n} 
\end{pmatrix} \begin{pmatrix}
u_1\\
u_2\\
u_3\\
...\\
...\\
u_n
\end{pmatrix} = \frac{1}{h^2}\begin{pmatrix}
f_1 \\
f_2-\frac{f_1 a_1}{b_1} \\
f_3 \\
... \\
... \\
f_n \\
\end{pmatrix}
\end{equation}

If we do this all the way to the end of the matrix, we get a new matrix with only non-zero elements on and above the diagonal. If we call the new values of the diagonal element $\tilde{b}$ we have an explicit expression for them as

\begin{equation}
	\tilde{b_i}=b_{i}-\frac{a_{i-1}c_{i-1}}{\tilde{b_{i-1}}}\quad i = 2, ..., n
	\label{eq:forward_general_b}
\end{equation}
We also have to update the $\mathbf{f}$ in a similar manner
\begin{equation}
	\tilde{f_i}=f_{i}-\frac{a_{i-1}f_{i-1}}{\tilde{b_{i-1}}}\quad i = 2, ..., n
	\label{eq:forward_general_f}
\end{equation}

In the end of this forward substitution we have

\begin{equation}
\begin{pmatrix}
b_1 & c_1 & 0 & ... & ... & 0 \\
0 & \tilde{b_2} & c_2 & 0 & ... & 0 \\
0 & 0 & \tilde{b_3} & c_3 & 0 & ... \\
... & ... & ... & ... & ... & ... \\
0 & ... & 0 & 0 & \tilde{b_{n-1}} & c_{n-1} \\
0 & 0 & ... & 0 & 0 & \tilde{b_{n}}
\end{pmatrix} \begin{pmatrix}
u_1\\
u_2\\
u_3\\
...\\
...\\
u_n
\end{pmatrix} = \frac{1}{h^2}\begin{pmatrix}
f_1 \\
\tilde{f_2} \\
\tilde{f_3} \\
... \\
... \\
\tilde{f_n} \\
\end{pmatrix}
\end{equation}

To continue we have to remove the elements above the diagonal. This time we first look at the elements in the last row that the first elements $u_n$ is given by $\tilde{f_n}/h^2$. To find the next elements $u_{n-1}$ we simply see that the equation for this row is 

\begin{equation}
	u_{n-1}\tilde{b_{n-1}}+c_{n-1}u_n = \frac{\tilde{f_{n-1}}}{h^2}
\end{equation}

We know all values except $u_{n-1}$ and solve for this value in an interative process upwards. This gives the algorithm 

\begin{equation}
	u_i = \frac{\frac{\tilde{f_i}}{h^2}-c_i u_{i+1}}{\tilde{a_i}}\quad i = n-1, n-2, ..., 1
	\label{eq:forward_general_u}
\end{equation}

were the sequence for the i's are important(i.e starting with the known value in the bottom). 

%% TODO:Antall steg i generell algoritme


We can then look at our specialized example were we know the coefficients of the matrix $\mathbf{A}$. By precalculation some of the algorithms we can reduce the number of operations for a given gridsize n by a substantial factor. If we insert the numbers into the first forward substitution equation \ref{eq:forward_general_b} we get

\begin{equation}
	\tilde{b_i}=2-\frac{1}{\tilde{b_{i-1}}}\quad i = 2, ..., n
\end{equation}

For n=2,3,4 we have 

\begin{align}
	\tilde{b_2}=2-\frac{1}{2}=\frac{3}{2} \\
	\tilde{b_3}=2-\frac{2}{3}=\frac{4}{3} \\
	\tilde{b_4}=2-\frac{3}{4}=\frac{5}{4}
\end{align}

were we start to suspect a series on the form

\begin{equation}
	\tilde{b_i}=\frac{i+1}{i}  \quad i = 2, ..., n
	\label{eq:forward_specific_b}
\end{equation}

We can see that this step only has 2n flops. The equations for $\mathbf{f}$ also simplify to a degree
\begin{equation}
	\tilde{f_i}=f_{i}+\frac{f_{i-1}}{\tilde{b_{i-1}}}\quad i = 2, ..., n
	\label{eq:forward_specific_f}
\end{equation}

where we now equally have 2n flops for this step. 

For the backward substitution we get 

\begin{equation}
	u_i = \frac{\frac{\tilde{f_i}}{h^2}+ u_{i+1}}{\tilde{a_i}}\quad i = n-1, n-2, ..., 1
	\label{eq:forward_specific_u}
\end{equation}

which has 4n$(2n?, 1/h^2 ?)$ flops. 

\subsection{Memory handling and algorithms}
To efficiently handle the memory and not generate lots of copies of the matrices, vectors are used as the algorithms act on a vector-type structure. For each round of the general algorithm, as in the forward substitution of b we can pass the array by reference and only update the values. The pseudocode for the forwards substitution would then be
\begin{lstlisting}
//general forward algorithm
//start at 1 as the 0 elements is ok
for (int i=1; i<=n; i++)
{
	b[i]=b[i]-c[i-1]*b[i-1]/b[i-1];
	f[i]=f[i]-c[i-1]*f[i-1]/b[i-1];
}
\end{lstlisting}


\begin{lstlisting}
//general backward algorithm
//start at 1 as the 0 elements is ok
for (int i=n-1; i>=0; i--)
{

}
\end{lstlisting}


\section*{Results}



\section*{Conclusion}















\begin{thebibliography}{3}
	
	\bibitem{lucia}
	Name of Author/s
	\emph{Name of work }
	Prublisher
	year
	\begin{verbatim}
	Web link
	\end{verbatim}
	
	
	
	
	
\end{thebibliography}









%__________________________________________________________________________
\end{document}

